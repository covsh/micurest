/*
 * Copyright (C) 2015 Eugene Hutorny <eugene@hutorny.in.ua>
 *
 * host.cpp - cojson tests, framework implementation for host platform
 *
 * This file is part of COJSON Library. http://hutorny.in.ua/projects/cojson
 *
 * The COJSON Library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License v2
 * as published by the Free Software Foundation;
 *
 * The COJSON Library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with the COJSON Library; if not, see
 * <http://www.gnu.org/licenses/gpl-2.0.html>.
 */

#include <utility>
#include <iostream>
#include "host-env.hpp"
#include "cojson_float.hpp"

//TODO run test by file & index (e.g. 101:4)
//TODO remove .cpp from text identity, e.g. 101.cpp:4 -> 101:4

#ifndef COJSON_SUITE_SIZE
#	define COJSON_SUITE_SIZE (200)
#endif

#ifndef COJSON_TEST_BUFFER_SIZE
#	define COJSON_TEST_BUFFER_SIZE (4096)
#endif
namespace cojson {
namespace test {
template<>
unsigned strlen(const wchar_t* s) noexcept {
	return wcslen(s);
}

template<>
unsigned strlen<const char16_t*>(const char16_t* s) noexcept {
	const char16_t* i = s;
	if(!i) return 0;
	while(*i) ++i;
	return i-s;
}
template<>
unsigned strlen<const char32_t*>(const char32_t* s) noexcept {
	const char32_t* i = s;
	if(!i) return 0;
	while(*i) ++i;
	return i-s;
}

template<>
bool match<const wchar_t*>(const wchar_t* a, void const* b, unsigned n) noexcept {
	return memcmp(a,b,n) == 0;
}
template<>
bool match<const char16_t*>(const char16_t* a, void const* b, unsigned n) noexcept {
	return memcmp(a,b,n) == 0;
}
template<>
bool match<const char32_t*>(const char32_t* a, void const* b, unsigned n) noexcept {
	return memcmp(a,b,n) == 0;
}

char_t buffer[COJSON_TEST_BUFFER_SIZE];
char_t* curr = buffer;

bool HostEnvironment::write(char_t b) const noexcept {
	if( curr - buffer < COJSON_TEST_BUFFER_SIZE )
		*curr++ = b;
	return false;
}

void HostEnvironment::dump(bool success) const noexcept {
	write(0);
	if( noout(success, true) ) return;
	const char *b = (const char*) buffer;
	if( *b ) {
		if( options.output == as_json ) dlm();
		fputs(b, stdout);
		dumped = true;
	}
}

void HostEnvironment::end() const noexcept  {
	if( options.output == as_json && dumped )
		fputc(']',stdout);
	dumped = false;
}


void HostEnvironment::master(tstring file, int index) const noexcept {
	if( ! options.make_masters ) return;
	const char_t* i = buffer;
	static const char* last_fail = nullptr;
	char filename[64];
	if(file == nullptr)
		return msg( verbosity::verbose, "WARN:\tNo file given, master was not created\n");
	mastername(file, filename);
	//size_t n = output.count();
	if( *i ) {
		msg(verbosity::debug,
				"opening output '%s' for test '%s'\n",filename, file);
		FILE* out = fopen(filename, index ? "a+" : "w");
		if( out == nullptr ) {
			if( last_fail != file ) {
				msg(verbosity::normal,
						"ERR:\tError %d writing to file '%s' - %s\n",
						errno, filename, strerror(errno));
				last_fail = file;
			}
			return;
		}
		fprintf(out,"_M_(%2d)=",index);
		fputs("\"", out);
		while(*i) {
			if( ! put(*i++, out) ) {
				if( last_fail != file && ferror(out) )
					msg(verbosity::silent,
						"ERR:\tError %d writing file '%s' - %s\n",
						ferror(out), filename, strerror(ferror(out)));
				last_fail = file;
			}
		}
		fputs("\";\n", out);
		fclose(out);
	}
}
void HostEnvironment::next() const noexcept {
	Environment::next();
	curr = buffer;
	*curr = 0;
}

}}

static HostEnvironment environment;

Environment& Environment::instance() noexcept {
	return environment;
}

using namespace coop;

BINAME(verbose,v)
BINAME(single,s)
BINAME(output,o)
BINAME(masters,m)
BINAME(chartable,t)
BINAME(help,?)
BINAME(benchmark,b)
BINAME(stoponfail,!)

typedef Environment::verbosity verbosity;
typedef Environment::dumping dumping;

static bool set_verbosity(const verbosity& v) noexcept {
	environment.setverbose(v);
	return true;
}

static bool set_benchmark(const long & v) noexcept {
	environment.setbenchmark(v);
	return true;
}

static bool set_verbose() noexcept {
	environment.setverbose(verbosity::verbose);
	return true;
}

static bool set_stoponfail() noexcept {
	environment.stoponfail(true);
	return true;
}

static bool set_out(const dumping& v) noexcept {
	environment.setoutlvl(v);
	return true;
}

static bool makemasters() noexcept {
	environment.makemasters(true);
	return true;
}

static int writechartable(FILE* out) {
	int i, l = 0;
	fprintf(out,
		"/*     chartable generated by cojson host test at build-time     */");
	for(i = 0; i < 128; ++i) {
		if( l >= 64 ) l = 0;
		l += fprintf(out,"%s%#7x,", l == 0 ? "\n" : "", chartype(i));
	}
	fputs("\n", out);
	return i;
}

static bool makechartable() noexcept {
	exit(writechartable(stdout));
}

static bool makechartable(const char* const & name) noexcept {
	FILE * f = fopen(name,"w");
	int r = writechartable(f);
	fclose(f);
	exit(r);
}


static bool set_single(const long& v) noexcept {
	unsigned count = Test::count();
	if( v <  0 || ((unsigned long)v) >= count ) {
		environment.msg(LVL::silent, "Test index %ld out of bounds 0-%d\n",
				v,count - 1);
		return false;
	}
	int s;
	if( (s = environment.getsingle()) >= 0 ) {
		environment.msg(LVL::silent,
			"Single test specified more than once: %d and %ld, using %d\n",
			s,v,s);
		return true;
	}
	environment.setsingle(v);
	return true;
}

namespace coop {
namespace details {

template<>
bool string_to<verbosity>(verbosity& dst, const char* src) noexcept {
	long l = -1;
	return string_to(l,src) &&
		((dst = static_cast<verbosity>(l)) >= verbosity::silent) &&
		( dst <= verbosity::debug );
}

template<>
bool string_to<dumping>(dumping& dst, const char* src) noexcept {
	static const char* longnames[] = {
		"nothing", "json", "positive", "all", "negative", nullptr };
	static const char* shortnames[] = {
		"-", "j", "p", "a", "n", nullptr };
	int n = string_find(shortnames, src);
	if( n < 0 ) n = string_find(longnames, src);
	return (n >= 0) &&
		((dst = static_cast<dumping>(n)) >= dumping::nothing) &&
		( dst <= dumping::negative );
}

}}

#ifdef COJSON_DEBUG
void dbg(const char *fmt, ...) noexcept {
	if( environment.getverbose() < LVL::debug ) return;
	va_list args;
	va_start(args, fmt);
	vfprintf(stderr, fmt, args);
	va_end(args);
}
#endif

static inline bool print_help_and_exit() noexcept {
	environment.msg(Environment::verbosity::silent,"Options are:\n"
			"-?   --help         print this help and exit\n"
			"-v=L --verbose=L    set verbosity level, L=0|1|2\n"
			"-v   --verbose      set verbosity level 2\n"
			"-b   --benchmark=N  run tests N times\n"
			"-m   --masters      make masters\n"
			"-t   --chartable    write chartable to stdio and exit"
			"-t=F --chartable=F  write chartable to file F and exit"
			"-!   --stoponfail   stops on first failed test\n"
			"-s=N --single=N     run signle test N\n"
			"N                   run signle test N\n"
			"-o=O --output=O     set output level, O =-|j|p|a|n|\n"
			"                    nothing|json|positive|all|negative\n");
	exit(1);
	return true;
}

int main(int argc, char** argv) noexcept {
	summary args = arguments<
		O<help, print_help_and_exit>,
		O<verbose, verbosity, set_verbosity>,/* -v=0|1|2	--verbose=0|1|2	*/
		O<verbose, set_verbose>,			/*	-v=0|1|2	--verbose=0|1|2	*/
		O<single, long, set_single>, 		/*	-s=N		--single=N 		*/
		O<benchmark, long, set_benchmark>,	/*	-b=N		--benchmark=N	*/
		O<long, set_single>,				/*	N							*/
		O<masters, makemasters>,			/*	-m			--masters		*/
		O<chartable, const char*, makechartable>, /*-t=F		--chartable=F	*/
		O<chartable, makechartable>,		/*	-t			--chartable		*/
		O<stoponfail, set_stoponfail>,
		O<output, dumping, set_out>			/*	-o=-|j|p|a|n
			--output=nothing|json|positive|all|negative  					*/
	>(argc,argv);
	if( args.unknown ) {
		environment.msg(LVL::silent, "Invalid option: '%s'\nUse -? for help\n", args.unknown);
		return 1;
	}

	return environment.isbenchmark() ?
		Test::benchmark(environment) : Test::runall(environment);
}



